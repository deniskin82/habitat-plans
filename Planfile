#!/bin/bash

## Simple workflow routine to fetch and sync community plans

#Inspired by:
# - https://syslog.ravelin.com/multi-to-mono-repository-c81d004df3ce
# - https://github.com/unravelin/tomono
# - https://leewc.com/articles/how-to-merge-multiple-git-repositories-into-one-repo/
# - https://github.com/metacloud/gilt
# - https://github.com/capr/multigit


P=./
W=.worktree
declare -a FETCHED=()
FETCH_WITH_ALL_DEPS=false
#set -x

plans() {

  use core https://github.com/habitat-sh/core-plans
  use ncerny https://github.com/ncerny/habitat-plans
  use qago https://github.com/qago/habitat-plans
  use jarvus https://github.com/JarvusInnovations/habitat-plans
  use eeyun https://github.com/eeyun/habitat-plans
  use starkandwayne https://github.com/starkandwayne/habitat-plans

  if ask "Get/Sync from upstream?" Y; then

    # stash uncommited changes
    git stash

    # origin/plan [--track core/develop]
    get core/etcd
    get core/vault
    get core/cacerts
    get ncerny/cfssl
    get ncerny/kubernetes
    get ncerny/kube-etcd
    get ncerny/etcd32
    get ncerny/etcd31
    get ncerny/kube-controller-manager
    get ncerny/kube-etcd
    get ncerny/kube-master
    get ncerny/kube-scheduler
    get ncerny/kube-apiserver

    # apply work in-progress
    git stash pop || true

  fi

  hooks

}

function hooks() {
  if [[ -e $P/.hooks ]]; then
    ask "Run hooks?" N && $P/.hooks
  fi
}

function git-all() {
  # git push/commit/... changes from all plans to branch on "meta" origin
  for p in $(ls -d ./*/); do
    pushd $p
    echo -e "\n# git-all: $(basename $PWD)"
    case "$1" in
      push)
        git push origin PLAN_ORIG/PLAN_BRANCH
      ;;
      commit)
        git commit $@
      ;;
      *)
        echo "Unsupported action for git-all function: $1"
      ;;
    esac
    popd
  done
}

function update() {
      pushd $1
      git stash
      git pull -r
      git stash pop || true
      popd
}

function use() {
  [[ -n "$1" ]] || die "USE called without an argument: remote name"
  [[ -n "$2" ]] || die "USE called without an argument: repo url"
  name=$1
  if ! git remote show | grep $name; then
    git remote add $@
  fi
}

function deps() {
  [[ -n "$1" ]] || die "GET_DEPS called without an argument: plan name"
  plan=$1
  # TODO: find out a better/safe way to parse dependencies
  # source plan.sh in order to get deps, regexes are used to avoid junk
  #      # pkg_.* and loops                # avoid bash maps
  eval "$(sed -e '/^[pkgcaseiffor].*/,/^[)]/!d' -e '/_map\|exports\|binds=.*/,/^[)]/d' $plan/plan.sh)" > /dev/null || true
  echo "${pkg_deps[@]} ${pkg_build_deps[@]}" |xargs -n1 --no-run-if-empty |awk -F'/' '{print $1"/"$2}'
}

function get() {
  # get core/etcd
  # get core/etcd --track core/staging -b core/etcd_staging
  [[ -n "$1" ]] || die "GET called without an argument: origin/plan_name"
  plan=$1
  name=$(basename $plan)
  origin=$(dirname $plan)

  # avoid duplicities
  if ! [[ "${FETCHED[*]}" =~ $name ]]; then
    echo -e "\n# $plan"
    if ! [[ -e $W/$plan ]]; then
      mkdir -p $W/$origin

      # fetch remote + add checkout to local worktree branch
      if [[ $# -gt 1 ]]; then
        git fetch $origin
        git worktree add -b "$plan" $W/$@         # arg. expansion!
      else
        git fetch $origin master
        git worktree add -b "$plan" $W/$plan --track $origin/master
      fi

      # TODO: support to add plan under custom name ?
      ln -sf $W/$plan/$name $name || ln -sf $W/$plan $name
      FETCHED+=($name)

    else
      # pull/rebase plan branch
      update $W/$plan
    fi

    # dependencies
    if ${FETCH_WITH_ALL_DEPS}; then
      for p in $(deps $name); do get $p; done
    fi
  fi
}

pushd () {
    command pushd "$@" > /dev/null
}

popd () {
    command popd "$@" > /dev/null
}

die () {
  echo "$@"
  exit 1
}


ask () {
  # https://djm.me/ask
  local prompt default reply

  while true; do

   if [ "${2:-}" = "Y" ]; then
       prompt="Y/n"
       default=Y
   elif [ "${2:-}" = "N" ]; then
       prompt="y/N"
       default=N
   else
       prompt="y/n"
       default=
   fi

   # Ask the question (not using "read -p" as it uses stderr not stdout)
   echo -en "\n$1 [$prompt] "

   # Read the answer (use /dev/tty in case stdin is redirected from somewhere else)
   read reply </dev/tty

   # Default?
   if [ -z "$reply" ]; then
       reply=$default
   fi

   # Check if the reply is valid
   case "$reply" in
       Y*|y*) return 0 ;;
       N*|n*) return 1 ;;
   esac

  done
}

# allow to be sourced to use functions independently
if [[ "$BASH_SOURCE" == "$0" ]]; then
  set -eu -o pipefail
  [[ -e $W ]] || mkdir -p $W
  [[ -e $P ]] || mkdir -p $P
  if [[ $# -gt 1 ]]; then
    fn=$1
    shift
    $fn $@
  else
    plans
  fi
fi
