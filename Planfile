#!/bin/bash

## Simple workflow routine to fetch and sync community plans

P=./
W=.branches
declare -a FETCHED=()
FETCH_WITH_ALL_DEPS=false
SYMLINK_PLAN_BRANCH=false
#set -x

plans() {

  use core https://github.com/habitat-sh/core-plans
  use ncerny https://github.com/ncerny/habitat-plans
  use qago https://github.com/qago/habitat-plans
  use jarvus https://github.com/JarvusInnovations/habitat-plans
  use eeyun https://github.com/eeyun/habitat-plans
  use starkandwayne https://github.com/starkandwayne/habitat-plans

  if ask "Get/Sync from upstream?" Y; then

    # stash uncommited changes
    git stash

    # origin/plan [--track core/develop]
    get core/etcd
    get core/vault
    get core/cacerts
    get ncerny/cfssl
    get ncerny/kubernetes
    get ncerny/kube-etcd
    get ncerny/etcd32
    get ncerny/etcd31
    get ncerny/kube-controller-manager
    get ncerny/kube-etcd
    get ncerny/kube-master
    get ncerny/kube-scheduler
    get ncerny/kube-apiserver

    # apply work in-progress
    git stash pop || true

  fi

  hooks

}

function hooks() {
  if [[ -e $P/.hooks ]]; then
    ask "Run hooks?" N && $P/.hooks
  fi
}

function git-all() {
  # git push/commit/... changes from all plans to branch on "meta" origin
  case "$1" in
    push)
      git push --all origin
    ;;
    commit)
      for p in $(ls -d ./*/); do
        pushd $p
        echo -e "\n# git-all: $(basename $PWD)"
            git commit $@
        popd
      done
    ;;
    add)
      find . -type l | xargs -n1 git add
    ;;
    *)
      echo "Unsupported action for git-all function: $1"
    ;;
  esac
}

function update() {
  pushd $1
  #FIXME, seems it can be dangerous to stash/pop when no changes (as pop may lay down other stashed changes)
  git stash
  git pull -r
  git stash pop || true
  popd
}

function use() {
  [[ -n "$1" ]] || die "USE called without an argument: remote name"
  [[ -n "$2" ]] || die "USE called without an argument: repo url"
  name=$1
  if ! git remote show | grep $name; then
    git remote add $@
  fi
}

function deps() {
  [[ -n "$1" ]] || die "GET_DEPS called without an argument: plan name"
  plan=$1
  # TODO: find out a better/safe way to parse dependencies
  # source plan.sh in order to get deps, regexes are used to avoid junk
  #      # pkg_.* and loops                # avoid bash maps
  eval "$(sed -e '/^[pkgcaseiffor].*/,/^[)]/!d' -e '/_map\|exports\|binds=.*/,/^[)]/d' $plan/plan.sh)" > /dev/null || true
  echo "${pkg_deps[@]} ${pkg_build_deps[@]}" |xargs -n1 --no-run-if-empty |awk -F'/' '{print $1"/"$2}'
}

function dirdiff() {
  git diff --no-index "$1" "$2" | colordiff;
}

function get() {
  # get core/etcd
  # get core/etcd --track core/staging -b core/etcd_staging
  [[ -n "$1" ]] || die "GET called without an argument: origin/plan_name"
  plan=$1
  name=$(basename $plan)
  origin=$(dirname $plan)

  # avoid duplicities
  if ! [[ "${FETCHED[*]}" =~ $name ]]; then
    echo -e "\n# $plan"
    if ! [[ -e $W/$plan ]]; then
      mkdir -p $W/$origin

      # fetch remote + add checkout to local worktree branch
      if [[ $# -gt 1 ]]; then
        git fetch $origin
        # --no-checkout
        git worktree add -b "$plan" $W/$@         # arg. expansion!
      else
        git fetch $origin master
        # --no-checkout
        git worktree add -b "$plan" $W/$plan --track $origin/master
      fi

      # monolitic repo -> sparse checkout
      if [[ -e $W/$plan/$name ]]; then
        sparse_checkout $W/$plan/$name $name
      fi

      if ${SYMLINK_PLAN_BRANCH}; then
        ln -sf $W/$plan/$name $name || ln -sf $W/$plan $name
      else
        rsync -avhLk --exclude '.git*' --filter=':- $W/$plan/.gitignore' $(plan_dir $plan $name)/ $name
      fi

    else
      update $W/$plan
      dirdiff $name $(plan_dir $plan $name) || true
    fi

    FETCHED+=($name)

    # dependencies
    if ${FETCH_WITH_ALL_DEPS}; then
      for p in $(deps $name); do get $p; done
    fi
  fi
}

function plan_dir() {
  # monolitic/single repo ?
  plan=$1
  name=$2

  if [[ -e $W/$plan/$name ]]; then
    echo $W/$plan/$name
  else
    echo $W/$plan
  fi
}

sparse_checkout() {
  repo=$1
  name=$2

  pushd $repo
  # sparse=.git/worktree/$name/info/sparse-checkout
  sparse=$(git rev-parse --git-path info/sparse-checkout)
  if ! $(grep $name $sparse > /dev/null 2>/dev/null ); then
    git config core.sparseCheckout true
    mkdir -p $(dirname $sparse)
    echo "$name" > $sparse
    git read-tree -mu HEAD
  fi
  popd
}

pushd () {
    command pushd "$@" > /dev/null
}

popd () {
    command popd "$@" > /dev/null
}

die () {
  echo "$@"
  exit 1
}


ask () {
  # https://djm.me/ask
  local prompt default reply

  while true; do

   if [ "${2:-}" = "Y" ]; then
       prompt="Y/n"
       default=Y
   elif [ "${2:-}" = "N" ]; then
       prompt="y/N"
       default=N
   else
       prompt="y/n"
       default=
   fi

   # Ask the question (not using "read -p" as it uses stderr not stdout)
   echo -en "\n$1 [$prompt] "

   # Read the answer (use /dev/tty in case stdin is redirected from somewhere else)
   read reply </dev/tty

   # Default?
   if [ -z "$reply" ]; then
       reply=$default
   fi

   # Check if the reply is valid
   case "$reply" in
       Y*|y*) return 0 ;;
       N*|n*) return 1 ;;
   esac

  done
}

# not used
function update-master() {
  git checkout develop
  path_master=$(git worktree list --porcelain | grep 'origin/master' | awk '/^worktree/{print $2}')
  ask "Really rewrite master branch ($path_master) with the content of current dir/branch?" N && \
    rsync -avhLk --delete-after --exclude '.*' --filter=':- .gitignore' $PWD/ $path_master
}


# allow to be sourced to use functions independently
if [[ "$BASH_SOURCE" == "$0" ]]; then
  set -eu -o pipefail
  [[ -e $W ]] || mkdir -p $W
  [[ -e $P ]] || mkdir -p $P
  if [[ $# -gt 0 ]]; then
    fn=$1
    shift
    $fn $@
  else
    plans
  fi
fi
